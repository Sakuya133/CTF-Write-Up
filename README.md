### Easy RSA 
```
Author: asbestos
“The security of RSA relies on the practical difficulty of factoring the product of two large prime numbers, the ‘factoring problem’” -Wikipedia
```
### easy_rsa.txt
```
n: 26518484190072684543796636642573643429663718007657844401363773206659586306986264997767920520901884078894807042866105584826044096909054367742753454178100533852686155634326578229244464083405472076784252798532101323300927917033985149599262487556178538148122012479094592746981412717431260240328326665253193374956717147239124238669998383943846418315819353858592278242580832695035016713351286816376107787722262574185450560176240134182669922757134881941918668067864082251416681188295948127121973857376227427652243249227143249036846400440184395983449367274506961173876131312502878352761335998067274325965774900643209446005663 
e: 65537 
c: 14348338827461086677721392146480940700779126717642704712390609979555667316222300910938184262325989361356621355740821450291276190410903072539047611486439984853997473162360371156442125577815817328959277482760973390721183548251315381656163549044110292209833480901571843401260931970647928971053471126873192145825248657671112394111129236255144807222107062898136588067644203143226369746529685617078054235998762912294188770379463390263607054883907325356551707971088954430361996309098504380934167675525860405086306135899933171103093138346158349497350586212612442120636759620471953311221396375007425956203746772190351265066237
```
We're given an RSA-encrypted ciphertext, along with the RSA modulus n and public exponent e. The goal is to recover the original plaintext flag.

##### n = the RSA modulus
##### e = the public exponent
##### c = ciphertext

### rsa_easy.py
```py
import random
from sympy import nextprime, mod_inverse


def gen_primes(bit_length, diff=2**525):
    p = nextprime(random.getrandbits(bit_length))
    q = nextprime(p + random.randint(diff//2, diff))
    return p, q


def gen_keys(bit_length=1024):
    p, q = gen_primes(bit_length)
    n = p * q
    phi = (p - 1) * (q - 1)

    e = 65537
    d = mod_inverse(e, phi)

    return (n, e)


def encrypt(message, public_key):
    n, e = public_key
    message_int = int.from_bytes(message.encode(), 'big')
    ciphertext = pow(message_int, e, n)
    return ciphertext


if __name__ == "__main__":
    public_key = gen_keys()

    message = "FLAG"
    ciphertext = encrypt(message, public_key)

    f = open("easy_rsa.txt", "a")
    f.write(f"n: {public_key[0]} \n")
    f.write(f"e: {public_key[1]} \n")
    f.write(f"c: {ciphertext}")
    f.close()
```
```py
def gen_primes(bit_length, diff=2**525):
    p = nextprime(random.getrandbits(bit_length))
    q = nextprime(p + random.randint(diff//2, diff))
```
from the code we can see:
The two prime numbers used in RSA, p and q in this challenge, they are very close to each other. Based on the code, q is picked by adding a small number to p. Because p and q are so close, we can use Fermat’s Factorization to break the RSA key. Fermat’s method works best when the two numbers (p and q) are close together. It tries to write the big number n as a difference of two squares:
```
n = a^2 - b^2
n = (a+b)(a-b)
```

if we can find a and b that fit this, we can get p and q easily. In this challenge, because p and q are so close, Fermat’s trick works quickly and lets us factor n. Once we have p and q, we can break RSA and get the flag.

### Decrypt.py
```py
from math import isqrt
from sympy import mod_inverse
from Crypto.Util.number import long_to_bytes


n = 26518484190072684543796636642573643429663718007657844401363773206659586306986264997767920520901884078894807042866105584826044096909054367742753454178100533852686155634326578229244464083405472076784252798532101323300927917033985149599262487556178538148122012479094592746981412717431260240328326665253193374956717147239124238669998383943846418315819353858592278242580832695035016713351286816376107787722262574185450560176240134182669922757134881941918668067864082251416681188295948127121973857376227427652243249227143249036846400440184395983449367274506961173876131312502878352761335998067274325965774900643209446005663
e = 65537
c = 14348338827461086677721392146480940700779126717642704712390609979555667316222300910938184262325989361356621355740821450291276190410903072539047611486439984853997473162360371156442125577815817328959277482760973390721183548251315381656163549044110292209833480901571843401260931970647928971053471126873192145825248657671112394111129236255144807222107062898136588067644203143226369746529685617078054235998762912294188770379463390263607054883907325356551707971088954430361996309098504380934167675525860405086306135899933171103093138346158349497350586212612442120636759620471953311221396375007425956203746772190351265066237

a = isqrt(n)
if a * a < n:
    a += 1

b2 = a * a - n
while isqrt(b2) ** 2 != b2:
    a += 1
    b2 = a * a - n

b = isqrt(b2)
p = a - b
q = a + b
assert p * q == n


phi = (p - 1) * (q - 1)
d = mod_inverse(e, phi)
m = pow(c, d, n)
flag = long_to_bytes(m)
print("FLAG:", flag)
```
